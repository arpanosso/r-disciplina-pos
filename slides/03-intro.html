<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introdução à Ciência dos Dados</title>
    <meta charset="utf-8" />
    <meta name="author" content="Alan R Panosso alan.panosso@unesp.br" />
    <script src="libs/header-attrs-2.28/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Introdução à Ciência dos Dados
]
.subtitle[
## Estatística e Experimentação no Ambiente R
]
.author[
### Alan R Panosso <a href="mailto:alan.panosso@unesp.br" class="email">alan.panosso@unesp.br</a>
]
.institute[
### Pós-graduação Agronomia (Ciência do Solo)
]
.date[
### 09 a 20 de dezembro de 2024
]

---



### Introdução à Ciência dos Dados

A Ciência dos Dados, ou *Data Science*, é uma área interdisciplinar voltada para o estudo e a análise de dados, estruturados e não-estruturados, que visa a extração de conhecimento, detecção de padrões e/ou obtenção de variáveis para possíveis tomadas de decisão. 

O modelo base das ferramentas necessárias em um projeto típico de ciência dos dados é parecido com isso:

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="../img/data-science.png" alt="Modelo base de um projeto de Ciência dos Dados." width="500px" /&gt;
&lt;p class="caption"&gt;Modelo base de um projeto de Ciência dos Dados.&lt;/p&gt;
&lt;/div&gt;

---

### Importação

Primeiro devemos *importar* os dados no R. Ou seja, pegar os dados armazenados em um arquivo, base de dados ou na Web e carregá-los em uma estrutuda de dados no R. 

Sem eles no R, não conseguiremos fazer Data Science.

Para essa prática, vamos utilizar um banco de dados oriundo de um estudo geomorfológico.

---

### Importação via web 

Acesse o banco de dados na web: Clique no link para o arquivo  [geomorfologia.txt](https://raw.githubusercontent.com/arpanosso/r-disciplina-pos/master/data/geomorfologia.txt)


``` r
# definir o caminho
URL &lt;- "https://raw.githubusercontent.com/arpanosso/r-disciplina-pos/master/data/geomorfologia.txt"
  
# Importação
dados&lt;-read.table(URL,header = TRUE) # cabeçalho na primeira linha
head(dados) # Inspeção do banco de dados
```

```
##   SUP Solo Amostra   X AMG   AG   AM   AF  AMF SILTE ARGILA  S_A AF_AG  P  pH
## 1   I   LV       1   0 0.2 3.72 20.4 22.9 30.0   1.2   21.5 0.05  6.16 42 4.2
## 2   I   LV       2  25 0.1 4.27 22.6 23.6 28.4   1.2   20.4 0.05  5.53 22 3.8
## 3   I   LV       3  50 0.7 5.00 22.7 22.2 26.9   1.2   21.4 0.05  4.44 41 4.8
## 4   I   LV       4  75 0.4 3.80 23.7 24.4 26.7   0.6   20.5 0.02  6.42 27 4.0
## 5   I   LV       5 100 0.4 3.10 22.3 24.6 26.9   2.1   20.7 0.10  7.94 11 4.4
## 6   I   LV       6 125 0.4 3.80 23.8 19.1 27.1   2.2   23.5 0.09  5.03 12 4.0
##      K  Ca  Mg H_Al   SB    T  V
## 1 0.27 1.4 0.3  5.2 1.97 7.17 27
## 2 0.11 0.4 0.1  5.8 0.61 6.41 10
## 3 0.34 2.4 0.4  4.2 3.14 7.34 43
## 4 0.13 0.7 0.1  5.2 0.93 6.13 15
## 5 0.11 1.4 0.3  4.2 1.81 6.01 30
## 6 0.14 0.6 0.1  5.2 0.84 6.04 14
```
---

### Importação via Excel

Acesse o banco de dados para essa prática, denominado [geomorfologia.xlsx](https://raw.githubusercontent.com/arpanosso/r-disciplina-pos/master/data/geomorfologia.xlsx), salve o arquivo em uma pasta de seu computador.

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="../img/import_1.png" alt="Na aba **Environment** selecione a opção **Import Dataser** e escolha **From Excel...**" width="500px" /&gt;
&lt;p class="caption"&gt;Na aba **Environment** selecione a opção **Import Dataser** e escolha **From Excel...**&lt;/p&gt;
&lt;/div&gt;

---

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="../img/import_2.png" alt="1) Clique em **Browse...**, acesse a pasta na qual você salvou o arquivo; 2) selecione o arquivo **geomorfologia.xlsx**; 3) clique em **Open.**" width="900px" /&gt;
&lt;p class="caption"&gt;1) Clique em **Browse...**, acesse a pasta na qual você salvou o arquivo; 2) selecione o arquivo **geomorfologia.xlsx**; 3) clique em **Open.**&lt;/p&gt;
&lt;/div&gt;

---

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="../img/import_3.png" alt="Pré-visualização dos dados, observe que o código de importação é apresentado abaixo dessa janela. Copie esse código, e clique em **CANCEL**." width="800px" /&gt;
&lt;p class="caption"&gt;Pré-visualização dos dados, observe que o código de importação é apresentado abaixo dessa janela. Copie esse código, e clique em **CANCEL**.&lt;/p&gt;
&lt;/div&gt;

---

Cole as linhas de código no script do R e as execute, para ter a importação dos dados.


``` r
library(readxl)
```

```
## Warning: package 'readxl' was built under R version 4.3.3
```

``` r
geomorfologia &lt;- read_excel("../data/geomorfologia.xlsx")
```

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="../img/import_4.png" alt="Após executar o código, os dados devem ser apresentados dessa forma." width="500px" /&gt;
&lt;p class="caption"&gt;Após executar o código, os dados devem ser apresentados dessa forma.&lt;/p&gt;
&lt;/div&gt;

---

### Organização

Uma vez que os dados estão no R, a próxima etapa é organizá-los, ou seja, armazená-los de uma forma consistente que combine a semântica da base de dados com a maneira com a qual eles são armazenados. 

Cada coluna é uma variável e cada linha é uma observação.

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="../img/dados.png" alt="Exemplo de dados organizados em planilha eletrônica, onde cada coluna é uma variável e cada linha é uma observação, ou registro." width="500px" /&gt;
&lt;p class="caption"&gt;Exemplo de dados organizados em planilha eletrônica, onde cada coluna é uma variável e cada linha é uma observação, ou registro.&lt;/p&gt;
&lt;/div&gt;

---

 &gt; Observação: O R, como a maioria dos softwares estatísticos, utiliza o **ponto** como **separador decimal**, ou seja, como o símbolo usado para separar a parte inteira da parte complementar não inteira da representação decimal do numeral de um real (ponto flutuante).
 
Portanto, aconselhamos a padronizar o separador decimal do seu computador. Para isso sigua os passos abaixo:


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="../img/meuGif_2.gif" alt="Acesse o PAINEL DE CONTROLE, na opção REGIÃO clique em  CONFIGURAÇÕES ADICIONAIS... e modifique o SÍBOLO DECIMAL para PONTO e o SÍMBOLO DE AGRUPAMENTO DE DÍGITO para VÍRGULA." width="600px" /&gt;
&lt;p class="caption"&gt;Acesse o PAINEL DE CONTROLE, na opção REGIÃO clique em  CONFIGURAÇÕES ADICIONAIS... e modifique o SÍBOLO DECIMAL para PONTO e o SÍMBOLO DE AGRUPAMENTO DE DÍGITO para VÍRGULA.&lt;/p&gt;
&lt;/div&gt;

---

Vamos conhecer a estrutura do nosso banco de dados, a partir da função `str`. 

Podemos identificar que os dados são compostos por 106 linhas e 22 colunas. As duas primeiras colunas são do tipo texto (**chr** - *character*) e as demais colunas são numéricas (**num** - *numeric*).


``` r
str(dados)
```

```
## 'data.frame':	106 obs. of  22 variables:
##  $ SUP    : chr  "I" "I" "I" "I" ...
##  $ Solo   : chr  "LV" "LV" "LV" "LV" ...
##  $ Amostra: int  1 2 3 4 5 6 7 8 9 10 ...
##  $ X      : int  0 25 50 75 100 125 150 175 200 225 ...
##  $ AMG    : num  0.2 0.1 0.7 0.4 0.4 0.4 1.2 0.8 1.1 1.2 ...
##  $ AG     : num  3.72 4.27 5 3.8 3.1 3.8 3.6 4.7 4.5 5.9 ...
##  $ AM     : num  20.4 22.6 22.7 23.7 22.3 23.8 23.1 25.8 25.5 32.8 ...
##  $ AF     : num  22.9 23.6 22.2 24.4 24.6 19.1 21.7 21.1 18.9 19.8 ...
##  $ AMF    : num  30 28.4 26.9 26.7 26.9 27.1 26.5 24.7 25.4 21.7 ...
##  $ SILTE  : num  1.2 1.2 1.2 0.6 2.1 2.2 0.7 0.2 2.5 0.2 ...
##  $ ARGILA : num  21.5 20.4 21.4 20.5 20.7 23.5 23.1 22.7 22 18.5 ...
##  $ S_A    : num  0.05 0.05 0.05 0.02 0.1 0.09 0.03 0.01 0.11 0.01 ...
##  $ AF_AG  : num  6.16 5.53 4.44 6.42 7.94 5.03 6.03 4.49 4.2 3.36 ...
##  $ P      : num  42 22 41 27 11 12 11 16 38 25 ...
##  $ pH     : num  4.2 3.8 4.8 4 4.4 4 4.8 5.4 4.4 5.2 ...
##  $ K      : num  0.27 0.11 0.34 0.13 0.11 0.14 0.23 0.28 0.19 0.14 ...
##  $ Ca     : num  1.4 0.4 2.4 0.7 1.4 0.6 1.6 3.3 1.6 2.9 ...
##  $ Mg     : num  0.3 0.1 0.4 0.1 0.3 0.1 0.7 1.3 0.5 1.7 ...
##  $ H_Al   : num  5.2 5.8 4.2 5.2 4.2 5.2 3.4 2.5 5.2 3.1 ...
##  $ SB     : num  1.97 0.61 3.14 0.93 1.81 0.84 2.53 4.88 2.29 4.74 ...
##  $ T      : num  7.17 6.41 7.34 6.13 6.01 6.04 5.93 7.38 7.49 7.84 ...
##  $ V      : num  27 10 43 15 30 14 43 66 31 60 ...
```


---


### Transformação dos dados

O termo transformação significa literalmente recortar o banco de dados, assim podemos focar nas observações de interesse. Criar novas variáveis em função das existentes e calcular, por exemplo, um resumo estatístico desse conjunto de interesse. 

Por exemplo, vamos selecionar somente os solos do tipo **LV**.


``` r
# Criar um filtro 
f &lt;- dados$Solo == "LV"

# Criar um banco de dados auxiliar da
da &lt;- dados[f,]

# Vamos ver a estrutura desse banco auxiliar
str(da)
```

```
## 'data.frame':	16 obs. of  22 variables:
##  $ SUP    : chr  "I" "I" "I" "I" ...
##  $ Solo   : chr  "LV" "LV" "LV" "LV" ...
##  $ Amostra: int  1 2 3 4 5 6 7 8 9 10 ...
##  $ X      : int  0 25 50 75 100 125 150 175 200 225 ...
##  $ AMG    : num  0.2 0.1 0.7 0.4 0.4 0.4 1.2 0.8 1.1 1.2 ...
##  $ AG     : num  3.72 4.27 5 3.8 3.1 3.8 3.6 4.7 4.5 5.9 ...
##  $ AM     : num  20.4 22.6 22.7 23.7 22.3 23.8 23.1 25.8 25.5 32.8 ...
##  $ AF     : num  22.9 23.6 22.2 24.4 24.6 19.1 21.7 21.1 18.9 19.8 ...
##  $ AMF    : num  30 28.4 26.9 26.7 26.9 27.1 26.5 24.7 25.4 21.7 ...
##  $ SILTE  : num  1.2 1.2 1.2 0.6 2.1 2.2 0.7 0.2 2.5 0.2 ...
##  $ ARGILA : num  21.5 20.4 21.4 20.5 20.7 23.5 23.1 22.7 22 18.5 ...
##  $ S_A    : num  0.05 0.05 0.05 0.02 0.1 0.09 0.03 0.01 0.11 0.01 ...
##  $ AF_AG  : num  6.16 5.53 4.44 6.42 7.94 5.03 6.03 4.49 4.2 3.36 ...
##  $ P      : num  42 22 41 27 11 12 11 16 38 25 ...
##  $ pH     : num  4.2 3.8 4.8 4 4.4 4 4.8 5.4 4.4 5.2 ...
##  $ K      : num  0.27 0.11 0.34 0.13 0.11 0.14 0.23 0.28 0.19 0.14 ...
##  $ Ca     : num  1.4 0.4 2.4 0.7 1.4 0.6 1.6 3.3 1.6 2.9 ...
##  $ Mg     : num  0.3 0.1 0.4 0.1 0.3 0.1 0.7 1.3 0.5 1.7 ...
##  $ H_Al   : num  5.2 5.8 4.2 5.2 4.2 5.2 3.4 2.5 5.2 3.1 ...
##  $ SB     : num  1.97 0.61 3.14 0.93 1.81 0.84 2.53 4.88 2.29 4.74 ...
##  $ T      : num  7.17 6.41 7.34 6.13 6.01 6.04 5.93 7.38 7.49 7.84 ...
##  $ V      : num  27 10 43 15 30 14 43 66 31 60 ...
```

---

Vamos continuar o processo de filtragem e selecionar somente as colunas **SUP**, **ARGILA**, **SILTE** e **T**.


``` r
da&lt;-da[,c(1,11,10,21)]
str(da)
```

```
## 'data.frame':	16 obs. of  4 variables:
##  $ SUP   : chr  "I" "I" "I" "I" ...
##  $ ARGILA: num  21.5 20.4 21.4 20.5 20.7 23.5 23.1 22.7 22 18.5 ...
##  $ SILTE : num  1.2 1.2 1.2 0.6 2.1 2.2 0.7 0.2 2.5 0.2 ...
##  $ T     : num  7.17 6.41 7.34 6.13 6.01 6.04 5.93 7.38 7.49 7.84 ...
```

Vamos criar uma nova variável, **ARG_SILT** a partir da soma dos valores de **ARGILA** + **SILTE**, para isso vamos utilizar o símbolo de acesso de colunas, o cifrão (**$**). Em seguida, aplicaremos a transformação logarítmica aos dados de **T**.   


``` r
da$ARG_SILT &lt;- da$ARGILA + da$SILTE
da$Log_T &lt;- log10(da$T)
str(da)
```

```
## 'data.frame':	16 obs. of  6 variables:
##  $ SUP     : chr  "I" "I" "I" "I" ...
##  $ ARGILA  : num  21.5 20.4 21.4 20.5 20.7 23.5 23.1 22.7 22 18.5 ...
##  $ SILTE   : num  1.2 1.2 1.2 0.6 2.1 2.2 0.7 0.2 2.5 0.2 ...
##  $ T       : num  7.17 6.41 7.34 6.13 6.01 6.04 5.93 7.38 7.49 7.84 ...
##  $ ARG_SILT: num  22.7 21.6 22.6 21.1 22.8 25.7 23.8 22.9 24.5 18.7 ...
##  $ Log_T   : num  0.856 0.807 0.866 0.787 0.779 ...
```

---

Agora vamos gerar um resumo estatístico para esses dados. A primeira coluna é do tipo texto, então, deve ser retirada do banco de dados auxiliar `da` antes de realizarmos os cálculos. Para isso, utilizamos o índice `\(-1\)` na dimensão das colunas do objeto `da`, ou seja, estamos retirando a coluna 1 **SUP** de `da`.


``` r
# Número de observações
apply(da[,-1],2,length)
```

```
##   ARGILA    SILTE        T ARG_SILT    Log_T 
##       16       16       16       16       16
```

``` r
# Média
apply(da[,-1],2,mean)
```

```
##     ARGILA      SILTE          T   ARG_SILT      Log_T 
## 21.1937500  1.2125000  6.2618750 22.4062500  0.7920605
```

``` r
# Mediana
apply(da[,-1],2,median)
```

```
##     ARGILA      SILTE          T   ARG_SILT      Log_T 
## 20.8500000  1.1000000  6.0850000 22.6500000  0.7842487
```


---


``` r
# Variância
apply(da[,-1],2,var)
```

```
##      ARGILA       SILTE           T    ARG_SILT       Log_T 
## 2.101958333 0.782500000 0.890589583 3.015291667 0.004318016
```

``` r
# Desvio Padrão
apply(da[,-1],2,sd)
```

```
##     ARGILA      SILTE          T   ARG_SILT      Log_T 
## 1.44981321 0.88459030 0.94371054 1.73645952 0.06571161
```

``` r
# Podemos utilizar a função summary.
summary(da[,-1])
```

```
##      ARGILA          SILTE             T            ARG_SILT    
##  Min.   :18.50   Min.   :0.200   Min.   :4.840   Min.   :18.70  
##  1st Qu.:20.48   1st Qu.:0.475   1st Qu.:5.760   1st Qu.:21.32  
##  Median :20.85   Median :1.100   Median :6.085   Median :22.65  
##  Mean   :21.19   Mean   :1.212   Mean   :6.262   Mean   :22.41  
##  3rd Qu.:22.18   3rd Qu.:2.125   3rd Qu.:7.213   3rd Qu.:23.20  
##  Max.   :23.50   Max.   :2.600   Max.   :7.840   Max.   :25.70  
##      Log_T       
##  Min.   :0.6848  
##  1st Qu.:0.7598  
##  Median :0.7842  
##  Mean   :0.7921  
##  3rd Qu.:0.8581  
##  Max.   :0.8943
```

---

Agora podemos gerar o conhecimento, por meio da **Visualização** e **Modelagem**.

Essas tem suas vantegens e desvantagens as quais são complementares, portanto, quaisquer análises reais farão muitas vezes iteraçoes entre elas.

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="../img/learnMath.jpeg" alt="Visualização e modelagem são dois processos iterativos, onde a matemática é uma ferramenta essencial para a extração de padrões, declaração e testes de hipóteses." width="400px" /&gt;
&lt;p class="caption"&gt;Visualização e modelagem são dois processos iterativos, onde a matemática é uma ferramenta essencial para a extração de padrões, declaração e testes de hipóteses.&lt;/p&gt;
&lt;/div&gt;

---

### Visualização

Atividade fundamentalmente humana, uma boa visualização lhe mostrará coisas que não esperava, ou levantará novas questões sobre os dados. Além disso, pode mostrar também que você esta fazendo a pergunta errada, ou que precisa coletar dados diferentes. Visualizações podem surpreender o analista de dados, mas não escalam particularmente bem, por que requerem um humano para interpretá-las.

---

class: middle, center


``` r
plot(da$ARGILA,da$T)
```

![](03-intro_files/figure-html/unnamed-chunk-17-1.png)&lt;!-- --&gt;

---

### Modelação

*Modelo* são ferramentas complementares da visualização. Uma vez que você tenha feito perguntas suficientemente precisas, poderá usar um modelo para respondê-las. Modelos são fundamentalmente matemáticos ou computacionais, então, geralmente escalam muito bem. Porém, cada modelo faz suposições e, por sua própria natureza, não podem questionar suas própria hipóteses, ou seja, um modelo não pode nos surpreender.


``` r
plot(da$ARGILA,da$T)
mod&lt;-lm(da$T~da$ARGILA)
summary.lm(mod)
```

```
## 
## Call:
## lm(formula = da$T ~ da$ARGILA)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -1.4256 -0.4641 -0.1615  0.9560  1.5268 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)  
## (Intercept)  6.66574    3.69347   1.805   0.0927 .
## da$ARGILA   -0.01906    0.17389  -0.110   0.9143  
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 0.9764 on 14 degrees of freedom
## Multiple R-squared:  0.000857,	Adjusted R-squared:  -0.07051 
## F-statistic: 0.01201 on 1 and 14 DF,  p-value: 0.9143
```

``` r
abline(mod)
```

![](03-intro_files/figure-html/unnamed-chunk-18-1.png)&lt;!-- --&gt;

---


### Exemplo de Análise multivariada (PCA)

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="../img/multivariada.png" alt="Classificação das técnicas multivariadas (Dependências e Interdependência)." width="400px" /&gt;
&lt;p class="caption"&gt;Classificação das técnicas multivariadas (Dependências e Interdependência).&lt;/p&gt;
&lt;/div&gt;


---

Carregando alguns pacotes


``` r
library(vegan)
```

```
## Carregando pacotes exigidos: permute
```

```
## Carregando pacotes exigidos: lattice
```

```
## This is vegan 2.6-8
```

``` r
library(corrplot)
```

```
## Warning: package 'corrplot' was built under R version 4.3.3
```

```
## corrplot 0.94 loaded
```

---
Matriz de Correlação


``` r
geomorfo_num &lt;- geomorfologia[-(1:5)]
matriz_correlacao &lt;- cor(geomorfo_num)
corrplot(matriz_correlacao)
```

![](03-intro_files/figure-html/unnamed-chunk-21-1.png)&lt;!-- --&gt;

---


``` r
corrplot(matriz_correlacao, method = "ellipse")
```

![](03-intro_files/figure-html/unnamed-chunk-22-1.png)&lt;!-- --&gt;

---


``` r
corrplot.mixed(matriz_correlacao, lower.col = "black", upper = "ellipse")
```

![](03-intro_files/figure-html/unnamed-chunk-23-1.png)&lt;!-- --&gt;


---
Notoriamente existem muitas variáveis, vamos filtar e transformas


``` r
str(geomorfo_num)
```

```
## tibble [106 × 17] (S3: tbl_df/tbl/data.frame)
##  $ AG    : num [1:106] 3.72 4.27 5 3.8 3.1 3.8 3.6 4.7 4.5 5.9 ...
##  $ AM    : num [1:106] 20.4 22.6 22.7 23.7 22.3 23.8 23.1 25.8 25.5 32.8 ...
##  $ AF    : num [1:106] 22.9 23.6 22.2 24.4 24.6 19.1 21.7 21.1 18.9 19.8 ...
##  $ AMF   : num [1:106] 30 28.4 26.9 26.7 26.9 27.1 26.5 24.7 25.4 21.7 ...
##  $ SILTE : num [1:106] 1.2 1.2 1.2 0.6 2.1 2.2 0.7 0.2 2.5 0.2 ...
##  $ ARGILA: num [1:106] 21.5 20.4 21.4 20.5 20.7 23.5 23.1 22.7 22 18.5 ...
##  $ S_A   : num [1:106] 0.05 0.05 0.05 0.02 0.1 0.09 0.03 0.01 0.11 0.01 ...
##  $ AF_AG : num [1:106] 6.16 5.53 4.44 6.42 7.94 5.03 6.03 4.49 4.2 3.36 ...
##  $ P     : num [1:106] 42 22 41 27 11 12 11 16 38 25 ...
##  $ pH    : num [1:106] 4.2 3.8 4.8 4 4.4 4 4.8 5.4 4.4 5.2 ...
##  $ K     : num [1:106] 0.27 0.11 0.34 0.13 0.11 0.14 0.23 0.28 0.19 0.14 ...
##  $ Ca    : num [1:106] 1.4 0.4 2.4 0.7 1.4 0.6 1.6 3.3 1.6 2.9 ...
##  $ Mg    : num [1:106] 0.3 0.1 0.4 0.1 0.3 0.1 0.7 1.3 0.5 1.7 ...
##  $ H_Al  : num [1:106] 5.2 5.8 4.2 5.2 4.2 5.2 3.4 2.5 5.2 3.1 ...
##  $ SB    : num [1:106] 1.97 0.61 3.14 0.93 1.81 0.84 2.53 4.88 2.29 4.74 ...
##  $ T     : num [1:106] 7.17 6.41 7.34 6.13 6.01 6.04 5.93 7.38 7.49 7.84 ...
##  $ V     : num [1:106] 27 10 43 15 30 14 43 66 31 60 ...
```

``` r
geomorfo_num$AREIA &lt;- geomorfo_num$AG + geomorfo_num$AM + geomorfo_num$AF + geomorfo_num$AMF
```

---

Vamos selecionar alguams variáveis


``` r
geomorfo_nun_selecionada &lt;- geomorfo_num[c("AREIA","SILTE","ARGILA", "P", "pH", "K","Ca","Mg","H_Al")]
matriz_correlacao_selecionada &lt;- cor(geomorfo_nun_selecionada)
corrplot.mixed(matriz_correlacao_selecionada,lower.col = "black", upper = "ellipse")
```

![](03-intro_files/figure-html/unnamed-chunk-25-1.png)&lt;!-- --&gt;

---

Para a análise de componente principais, primeiramente devemos padronizar o banco de dados, assim utilizamos o argumento `scale = TRUE` da funçaõ `prcompr`.


``` r
da &lt;- decostand(geomorfo_nun_selecionada,method = "standardize",na.rm = TRUE)
pca &lt;- prcomp(geomorfo_nun_selecionada,scale. = TRUE)
summary(pca)
```

```
## Importance of components:
##                           PC1    PC2    PC3     PC4     PC5     PC6     PC7
## Standard deviation     1.9208 1.5089 1.1682 0.89358 0.69509 0.51859 0.24150
## Proportion of Variance 0.4099 0.2530 0.1516 0.08872 0.05368 0.02988 0.00648
## Cumulative Proportion  0.4099 0.6629 0.8146 0.90328 0.95697 0.98685 0.99333
##                            PC8     PC9
## Standard deviation     0.19093 0.15359
## Proportion of Variance 0.00405 0.00262
## Cumulative Proportion  0.99738 1.00000
```

---

Extraindo os autovalores


``` r
eig &lt;- pca$sdev^2
eig
```

```
## [1] 3.68947383 2.27684828 1.36474606 0.79848178 0.48314722 0.26893875 0.05832218
## [8] 0.03645306 0.02358884
```

Porcentagem da variância explicada por cada componente


``` r
ve&lt;-eig/sum(eig)
ve
```

```
## [1] 0.409941537 0.252983142 0.151638451 0.088720198 0.053683025 0.029882083
## [7] 0.006480242 0.004050340 0.002620982
```

Porcentagem acumulada

``` r
cumsum(ve)
```

```
## [1] 0.4099415 0.6629247 0.8145631 0.9032833 0.9569664 0.9868484 0.9933287
## [8] 0.9973790 1.0000000
```




---
Correlações entre cada variável - poder discriminante

``` r
mcor&lt;-cor(da, pca$x) 
corrplot(mcor)
```

![](03-intro_files/figure-html/unnamed-chunk-31-1.png)&lt;!-- --&gt;

---

Screeplot, para verificar os PC maiores que a Unidade, de acordo com Kaiser, valores maiores que 1


``` r
screeplot(pca)
```

![](03-intro_files/figure-html/unnamed-chunk-32-1.png)&lt;!-- --&gt;

``` r
barplot(eig,
        names.arg=colnames(pca$rotation),
        ylim=c(0,(pca$sdev^2)[1]*1.1),
    ylab="Inertia",xlab="Principal Component",cex.lab=1.2
    ,main="Sreeplot")
abline(h=1,lty=2)
```

![](03-intro_files/figure-html/unnamed-chunk-32-2.png)&lt;!-- --&gt;

``` r
grupos &lt;- geomorfologia$SUP
```

---

Construção do Biplot e sua tabela

``` r
biplot(rda(da),pch=2)
ordihull(rda(da),
         group = grupos,
         col=1:nlevels(as.factor(grupos)))
```

![](03-intro_files/figure-html/unnamed-chunk-33-1.png)&lt;!-- --&gt;

---

Construção do biplot usando as funções básicas

``` r
pc1V&lt;-cor(da,pca$x)[,1]/sd(cor(da,pca$x)[,1])
pc2V&lt;-cor(da,pca$x)[,2]/sd(cor(da,pca$x)[,2])
pc1c&lt;-pca$x[,1]/sd(pca$x[,1])
pc2c&lt;-pca$x[,2]/sd(pca$x[,2])
nv&lt;-ncol(da) # número de variáveis utilizadas na análise
plot(pc1V,pc2V,
     xlim=c(min(-3,pc1V,pc1c),
            max(pc1V,pc1c,5)),
     ylim=c(min(pc2V,pc2c),
            max(pc2V,pc2c)),pch="",las=1,
     xlab=paste("PC1 (",round(100*ve[1],2),"%)",sep=""),
     ylab=paste("PC2 (",round(100*ve[2],2),"%)",sep=""),
     font.lab=2)
abline(v=0,h=0)
arrows(rep(0,nv),rep(0,nv),pc1V*.90,pc2V*.90,lwd=1.5,length=.1)
text(pc1V,pc2V,names(pc1V),font=4)
lv&lt;-as.factor(grupos);nlv&lt;-levels(lv)

# Adicionando os identificadores dos acesso partir de uma variável categórica
for(i in 1:length(nlv)){
  ff&lt;-lv==nlv[i]  
  # points(pc1c[ff],pc2c[ff],cex=1.3,col=i,pch=i+15) 
  # df$Municípios[ff]
   text(pc1c[ff],pc2c[ff],grupos[ff],cex=.8,col=i)}
```

---

### Biplot

![](03-intro_files/figure-html/plot_1-1.png)&lt;!-- --&gt;

---

Tabela do Biplot com as correlações com as PCs e seus respectivos autovetores

``` r
ck&lt;-sum(pca$sdev^2&gt;=1)
tabelapca&lt;-vector()
for( l in 1:ck) tabelapca&lt;-cbind(tabelapca,mcor[,l])#,pca$rotation[,l])
colnames(tabelapca)&lt;-paste(rep(c("PC"),ck),1:ck,sep="")
pcat&lt;-round(tabelapca,3)
tabelapca&lt;-tabelapca[order(abs(tabelapca[,1])),]
tabelapca
```

```
##                PC1         PC2         PC3
## P       0.08588849  0.06523595 -0.74469586
## K       0.17453865 -0.09655659 -0.72460429
## AREIA   0.45919323  0.81459224  0.17361541
## SILTE   0.62733966 -0.59857849  0.28629486
## ARGILA -0.68956146 -0.60629820 -0.27491327
## Ca      0.71745561 -0.64652319  0.05554402
## H_Al   -0.77429361 -0.44592300  0.13433788
## Mg      0.80916440 -0.49156593  0.05874232
## pH      0.89593784  0.12384873 -0.26991837
```

---

Uma opção à tabela resumo


``` r
library(plotrix)
{
  pyramid.plot(abs(tabelapca[,1]),abs(tabelapca[,2]),
               labels = names(tabelapca[,1]),
               unit="Correlation",gap=.1,raxlab=c(0,0.25,.5,.75,1),
               top.labels = c("PC1 (33.85%)", "Variable", "PC2 (25.16%)"),
               laxlab=c(0,0.25,.5,.75,1),
               lxcol=c("darkgray","white","darkgray","darkgray","darkgray",
                       "darkgray"),
               rxcol=c("white","white","darkgray","darkgray",
                       "white","white"))
  text(-1*abs(tabelapca[,1]),1:6,round(tabelapca[,1],2))
  text(abs(tabelapca[,2]+c(0,0,0,0,-.04,0)),1:6,round(tabelapca[,2],2))
  box()
}
```

---


```
## Warning: package 'plotrix' was built under R version 4.3.2
```

```
## 1 1
```

```
## Warning in tabelapca[, 2] + c(0, 0, 0, 0, -0.04, 0): comprimento do objeto
## maior não é múltiplo do comprimento do objeto menor
```

![](03-intro_files/figure-html/plot_2-1.png)&lt;!-- --&gt;


---
### Comunicação

É a última etapa do Data Science, a mais importante. Não importa quão bem seus modelos e visualizações o levaram a entender os dados, a menos que você também consiga comunicar seus resultados para outras pessoas.

Uma dica importante, é estudar **RMarkdown**! Ótima linguagem de marcação de texto, utilizada para gerar relatórios em HTML, .doc e pdf. Inclusive, esse material que estamos utilizando no curso.

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="../img/coverRMD.png" alt="https://bookdown.org/yihui/rmarkdown-cookbook/" width="200px" /&gt;
&lt;p class="caption"&gt;https://bookdown.org/yihui/rmarkdown-cookbook/&lt;/p&gt;
&lt;/div&gt;

---
### Programação

Permeia todas as etapas da Ciência dos Dados.

Ao nosso ver é uma questão recursiva...

O computador é a ferramenta do cientista de dados.

R é um ambiente e linguagem de programação de código aberto para computação estatística, bioinformática e gráficos.

  * Como linguagem de programação, garante a reprodutibilidade das análises.
  
    + Estudantes podem usar as mesmas ferramentas que os profissionais.

    + Todos podem usar as melhores ferramentas independente do poder financeiro.

    + Qualquer um pode reproduzir as suas análises.

    + Você pode corrigir problemas.

    + Você pode desenvolver suas próprias ferramentas.

---

  * Linguagem orientada a objetos R  (Ross Ihaka e Robert Gentleman).

  * R é uma poderosa linguagem, flexível e possui excelentes facilidades gráficas.

  * R é um projeto **open-source** e está disponível na internet sobre a General Public License (&lt;www.gnu.org/copyleft/gpl.html&gt; e &lt;www.fsf.org&gt;).

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
